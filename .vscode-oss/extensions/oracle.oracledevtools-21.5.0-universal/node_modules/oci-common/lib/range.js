"use strict";
/**
 * Copyright (c) 2020, 2021 Oracle and/or its affiliates.  All rights reserved.
 * This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Range = void 0;
class Range {
    /**
     * Construct an instance of [[Range]].
     * @param startByte The start byte, if given.
     * @param endByte  The end byte, if given.
     * @param contentLength The content length as returned by the server, or null if unknown.
     */
    constructor(startByte, endByte, contentLength) {
        this.startByte = startByte;
        this.endByte = endByte;
        this.contentLength = contentLength;
        this.startByte = startByte;
        this.endByte = endByte;
        this.contentLength = contentLength;
    }
    /**
     * Parse the "content-range" header per https://tools.ietf.org/html/rfc7233#section-4.2.
     * <p>
     * Note, this is only for successful responses (206).  It does not handle 416 (range not satisfiable).
     * @param value The response header value.
     * @return A new Range header.
     */
    static parse(value) {
        console.debug("Attempting to parse range: %s", value);
        value = value.replace("bytes", "").trim();
        const parts = value.split("/");
        if (parts.length != 2)
            throw Error("Must provide <range>/<length> format for range request: " + value);
        const byteRangePart = parts[0];
        const contentLengthPart = parts[1];
        const contentLength = contentLengthPart === "*" ? null : Number(contentLengthPart);
        const byteValues = byteRangePart.split("-", -1); // include trailing empty strings
        if (byteValues.length != 2) {
            throw new Error("Must provide <start>-<end> format for range request: " + value);
        }
        const startByte = byteValues[0] === "" ? null : Number(byteValues[0]);
        const endByte = byteValues[1] === "" ? null : Number(byteValues[1]);
        if (startByte == null && endByte == null) {
            throw new Error("Must provide start/end byte for range request: " + value);
        }
        let range = new Range(startByte, endByte, contentLength);
        return range;
        return;
    }
}
exports.Range = Range;
//# sourceMappingURL=range.js.map